# Простой планировщик

[Task link](https://stepik.org/lesson/44337/step/3?unit=22150)

В этом задании вам потребуется реализовать планировщик, использующий алгоритм Round Robin. Реализация планировщика состоит из нескольких функций:

* **void scheduler_setup(int timeslice)** - вызывается перед началом работы, а timeslice - квант времени, который нужно использовать в некоторых единицах времени (что именно используется как единица времени, не существенно);
* **void new_thread(int thread_id)** - оповещает планировщик о новом потоке с идентификатором thread_id;
* **void exit_thread()** - оповещает планировщик о том, что текущий исполняемый на CPU поток завершился (соответственно, планировщик должен отдать CPU кому-то другому);
* **void block_thread()** - оповещает планировщик, что текущий исполняемый поток был заблокирован (например, запросил IO операцию и должен отдать CPU);
* **void wake_thread(int thread_id)** - оповещает, что поток с идентификатором thread_id был разблокирован (например, IO операция завершилась);
* **void timer_tick()** - вызывается через равные интервалы времени, нотифицирует, что прошла одна единица времени;
* **int current_thread(void)** - функция должна возвращать идентификатор потока, который сейчас должен выполняться на CPU, если такого потока нет, то нужно вернуть -1.

При выполнении задания каждый раз, когда поток выполняется на CPU и вызывается **timer_tick**, считайте, что поток отработал целую единицу времени на CPU. Т. е. даже если предыдущий поток добровольно освободил CPU (вызвав **block_thread** или **exit_thread**) и сразу после того, как CPU был отдан другому потоку, была вызвана функция **timer_tick**, то все равно считается, что второй поток отработал целую единицу времени на CPU.